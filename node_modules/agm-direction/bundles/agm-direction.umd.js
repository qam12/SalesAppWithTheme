(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('agm-direction', ['exports', '@angular/core', 'rxjs'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.angularLibraryStarter = {}),global.ng.core,global.rxjs));
}(this, (function (exports,core,rxjs) { 'use strict';

    var MapsAPILoader = /** @class */ (function () {
        function MapsAPILoader() {
        }
        MapsAPILoader.decorators = [
            { type: core.Injectable },
        ];
        return MapsAPILoader;
    }());

    /**
     * Wrapper class that handles the communication with the Google Maps Javascript
     * API v3
     */
    var GoogleMapsAPIWrapper = /** @class */ (function () {
        function GoogleMapsAPIWrapper(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._map =
                new Promise(function (resolve) { _this._mapResolver = resolve; });
        }
        GoogleMapsAPIWrapper.prototype.createMap = function (el, mapOptions) {
            var _this = this;
            return this._zone.runOutsideAngular(function () {
                return _this._loader.load().then(function () {
                    var map = new google.maps.Map(el, mapOptions);
                    _this._mapResolver(map);
                    return;
                });
            });
        };
        GoogleMapsAPIWrapper.prototype.setMapOptions = function (options) {
            this._map.then(function (m) { m.setOptions(options); });
        };
        /**
         * Creates a google map marker with the map context
         */
        /**
           * Creates a google map marker with the map context
           */
        GoogleMapsAPIWrapper.prototype.createMarker = /**
           * Creates a google map marker with the map context
           */
        function (options, addToMap) {
            if (options === void 0) { options = {}; }
            if (addToMap === void 0) { addToMap = true; }
            return this._map.then(function (map) {
                if (addToMap) {
                    options.map = map;
                }
                return new google.maps.Marker(options);
            });
        };
        GoogleMapsAPIWrapper.prototype.createInfoWindow = function (options) {
            return this._map.then(function () { return new google.maps.InfoWindow(options); });
        };
        /**
         * Creates a google.map.Circle for the current map.
         */
        /**
           * Creates a google.map.Circle for the current map.
           */
        GoogleMapsAPIWrapper.prototype.createCircle = /**
           * Creates a google.map.Circle for the current map.
           */
        function (options) {
            return this._map.then(function (map) {
                options.map = map;
                return new google.maps.Circle(options);
            });
        };
        GoogleMapsAPIWrapper.prototype.createPolyline = function (options) {
            return this.getNativeMap().then(function (map) {
                var line = new google.maps.Polyline(options);
                line.setMap(map);
                return line;
            });
        };
        GoogleMapsAPIWrapper.prototype.createPolygon = function (options) {
            return this.getNativeMap().then(function (map) {
                var polygon = new google.maps.Polygon(options);
                polygon.setMap(map);
                return polygon;
            });
        };
        /**
         * Creates a new google.map.Data layer for the current map
         */
        /**
           * Creates a new google.map.Data layer for the current map
           */
        GoogleMapsAPIWrapper.prototype.createDataLayer = /**
           * Creates a new google.map.Data layer for the current map
           */
        function (options) {
            return this._map.then(function (m) {
                var data = new google.maps.Data(options);
                data.setMap(m);
                return data;
            });
        };
        /**
         * Determines if given coordinates are insite a Polygon path.
         */
        /**
           * Determines if given coordinates are insite a Polygon path.
           */
        GoogleMapsAPIWrapper.prototype.containsLocation = /**
           * Determines if given coordinates are insite a Polygon path.
           */
        function (latLng, polygon) {
            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        };
        GoogleMapsAPIWrapper.prototype.subscribeToMapEvent = function (eventName) {
            var _this = this;
            return new rxjs.Observable(function (observer) {
                _this._map.then(function (m) {
                    m.addListener(eventName, function (arg) { _this._zone.run(function () { return observer.next(arg); }); });
                });
            });
        };
        GoogleMapsAPIWrapper.prototype.clearInstanceListeners = function () {
            this._map.then(function (map) {
                google.maps.event.clearInstanceListeners(map);
            });
        };
        GoogleMapsAPIWrapper.prototype.setCenter = function (latLng) {
            return this._map.then(function (map) { return map.setCenter(latLng); });
        };
        GoogleMapsAPIWrapper.prototype.getZoom = function () { return this._map.then(function (map) { return map.getZoom(); }); };
        GoogleMapsAPIWrapper.prototype.getBounds = function () {
            return this._map.then(function (map) { return map.getBounds(); });
        };
        GoogleMapsAPIWrapper.prototype.getMapTypeId = function () {
            return this._map.then(function (map) { return map.getMapTypeId(); });
        };
        GoogleMapsAPIWrapper.prototype.setZoom = function (zoom) {
            return this._map.then(function (map) { return map.setZoom(zoom); });
        };
        GoogleMapsAPIWrapper.prototype.getCenter = function () {
            return this._map.then(function (map) { return map.getCenter(); });
        };
        GoogleMapsAPIWrapper.prototype.panTo = function (latLng) {
            return this._map.then(function (map) { return map.panTo(latLng); });
        };
        GoogleMapsAPIWrapper.prototype.panBy = function (x, y) {
            return this._map.then(function (map) { return map.panBy(x, y); });
        };
        GoogleMapsAPIWrapper.prototype.fitBounds = function (latLng) {
            return this._map.then(function (map) { return map.fitBounds(latLng); });
        };
        GoogleMapsAPIWrapper.prototype.panToBounds = function (latLng) {
            return this._map.then(function (map) { return map.panToBounds(latLng); });
        };
        /**
         * Returns the native Google Maps Map instance. Be careful when using this instance directly.
         */
        /**
           * Returns the native Google Maps Map instance. Be careful when using this instance directly.
           */
        GoogleMapsAPIWrapper.prototype.getNativeMap = /**
           * Returns the native Google Maps Map instance. Be careful when using this instance directly.
           */
        function () { return this._map; };
        /**
         * Triggers the given event name on the map instance.
         */
        /**
           * Triggers the given event name on the map instance.
           */
        GoogleMapsAPIWrapper.prototype.triggerMapEvent = /**
           * Triggers the given event name on the map instance.
           */
        function (eventName) {
            return this._map.then(function (m) { return google.maps.event.trigger(m, eventName); });
        };
        GoogleMapsAPIWrapper.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapsAPIWrapper.ctorParameters = function () { return [
            { type: MapsAPILoader, },
            { type: core.NgZone, },
        ]; };
        return GoogleMapsAPIWrapper;
    }());

    var WindowRef = /** @class */ (function () {
        function WindowRef() {
        }
        WindowRef.prototype.getNativeWindow = function () { return window; };
        return WindowRef;
    }());
    var DocumentRef = /** @class */ (function () {
        function DocumentRef() {
        }
        DocumentRef.prototype.getNativeDocument = function () { return document; };
        return DocumentRef;
    }());

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var GoogleMapsScriptProtocol;
    (function (GoogleMapsScriptProtocol) {
        GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
        GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
        GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
    })(GoogleMapsScriptProtocol || (GoogleMapsScriptProtocol = {}));
    /**
     * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link
     * LazyMapsAPILoaderConfig}.
     */
    var LAZY_MAPS_API_CONFIG = new core.InjectionToken('angular-google-maps LAZY_MAPS_API_CONFIG');
    var LazyMapsAPILoader = /** @class */ (function (_super) {
        __extends(LazyMapsAPILoader, _super);
        function LazyMapsAPILoader(config, w, d) {
            if (config === void 0) { config = null; }
            var _this = _super.call(this) || this;
            _this._SCRIPT_ID = 'agmGoogleMapsApiScript';
            _this.callbackName = "agmLazyMapsAPILoader";
            _this._config = config || {};
            _this._windowRef = w;
            _this._documentRef = d;
            return _this;
        }
        LazyMapsAPILoader.prototype.load = function () {
            var window = this._windowRef.getNativeWindow();
            if (window.google && window.google.maps) {
                // Google maps already loaded on the page.
                return Promise.resolve();
            }
            if (this._scriptLoadingPromise) {
                return this._scriptLoadingPromise;
            }
            // this can happen in HMR situations or Stackblitz.io editors.
            var scriptOnPage = this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);
            if (scriptOnPage) {
                this._assignScriptLoadingPromise(scriptOnPage);
                return this._scriptLoadingPromise;
            }
            var script = this._documentRef.getNativeDocument().createElement('script');
            script.type = 'text/javascript';
            script.async = true;
            script.defer = true;
            script.id = this._SCRIPT_ID;
            script.src = this._getScriptSrc(this.callbackName);
            this._assignScriptLoadingPromise(script);
            this._documentRef.getNativeDocument().body.appendChild(script);
            return this._scriptLoadingPromise;
        };
        LazyMapsAPILoader.prototype._assignScriptLoadingPromise = function (scriptElem) {
            var _this = this;
            this._scriptLoadingPromise = new Promise(function (resolve, reject) {
                _this._windowRef.getNativeWindow()[_this.callbackName] = function () {
                    resolve();
                };
                scriptElem.onerror = function (error) {
                    reject(error);
                };
            });
        };
        LazyMapsAPILoader.prototype._getScriptSrc = function (callbackName) {
            var protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;
            var protocol;
            switch (protocolType) {
                case GoogleMapsScriptProtocol.AUTO:
                    protocol = '';
                    break;
                case GoogleMapsScriptProtocol.HTTP:
                    protocol = 'http:';
                    break;
                case GoogleMapsScriptProtocol.HTTPS:
                    protocol = 'https:';
                    break;
            }
            var hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
            var queryParams = {
                v: this._config.apiVersion || '3',
                callback: callbackName,
                key: this._config.apiKey,
                client: this._config.clientId,
                channel: this._config.channel,
                libraries: this._config.libraries,
                region: this._config.region,
                language: this._config.language
            };
            var params = Object.keys(queryParams)
                .filter(function (k) { return queryParams[k] != null; })
                .filter(function (k) {
                // remove empty arrays
                return !Array.isArray(queryParams[k]) ||
                    (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
            })
                .map(function (k) {
                // join arrays as comma seperated strings
                var i = queryParams[k];
                if (Array.isArray(i)) {
                    return { key: k, value: i.join(',') };
                }
                return { key: k, value: queryParams[k] };
            })
                .map(function (entry) {
                return entry.key + "=" + entry.value;
            })
                .join('&');
            return protocol + "//" + hostAndPath + "?" + params;
        };
        LazyMapsAPILoader.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        LazyMapsAPILoader.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [LAZY_MAPS_API_CONFIG,] },] },
            { type: WindowRef, },
            { type: DocumentRef, },
        ]; };
        return LazyMapsAPILoader;
    }(MapsAPILoader));

    /**
     * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`
     * Tag.
     * It's important that the Google Maps API script gets loaded first on the page.
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AgmDirection = /** @class */ (function () {
        function AgmDirection(gmapsApi) {
            this.gmapsApi = gmapsApi;
            this.travelMode = 'DRIVING';
            this.transitOptions = undefined;
            this.drivingOptions = undefined;
            this.waypoints = [];
            this.optimizeWaypoints = true;
            this.provideRouteAlternatives = false;
            this.avoidHighways = false;
            this.avoidTolls = false;
            this.visible = true;
            // Direction change event handler
            this.onChange = new core.EventEmitter();
            // Direction response for the new request
            this.onResponse = new core.EventEmitter();
            this.sendInfoWindow = new core.EventEmitter();
            this.directionsService = undefined;
            this.directionsDisplay = undefined;
            this.waypointsMarker = [];
            this.isFirstChange = true;
        }
        /**
         * @return {?}
         */
        AgmDirection.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.visible === true) {
                this.directionDraw();
            }
        };
        /**
         * @param {?} obj
         * @return {?}
         */
        AgmDirection.prototype.ngOnChanges = /**
         * @param {?} obj
         * @return {?}
         */
        function (obj) {
            /**
                 * When visible is false then remove the direction layer
                 */
            if (!this.visible) {
                try {
                    if (typeof this.originMarker !== 'undefined') {
                        this.originMarker.setMap(null);
                        this.destinationMarker.setMap(null);
                        this.waypointsMarker.forEach(function (w) { return w.setMap(null); });
                    }
                    this.directionsDisplay.setPanel(null);
                    this.directionsDisplay.setMap(null);
                    this.directionsDisplay = undefined;
                }
                catch (/** @type {?} */ e) { }
            }
            else {
                if (this.isFirstChange) {
                    /**
                             * When visible is false at the first time
                             */
                    if (typeof this.directionsDisplay === 'undefined') {
                        this.directionDraw();
                    }
                    this.isFirstChange = false;
                    return;
                }
                /**
                       * When renderOptions are not first change then reset the display
                       */
                if (typeof obj.renderOptions !== 'undefined') {
                    if (obj.renderOptions.firstChange === false) {
                        if (typeof this.originMarker !== 'undefined') {
                            this.originMarker.setMap(null);
                            this.destinationMarker.setMap(null);
                            this.waypointsMarker.forEach(function (w) { return w.setMap(null); });
                        }
                        this.directionsDisplay.setPanel(null);
                        this.directionsDisplay.setMap(null);
                        this.directionsDisplay = undefined;
                    }
                }
                this.directionDraw();
            }
        };
        /**
         * This event is fired when the user creating or updating this direction
         * @return {?}
         */
        AgmDirection.prototype.directionDraw = /**
         * This event is fired when the user creating or updating this direction
         * @return {?}
         */
        function () {
            var _this = this;
            this.gmapsApi.getNativeMap().then(function (map) {
                if (typeof _this.directionsDisplay === 'undefined') {
                    _this.directionsDisplay = new google.maps.DirectionsRenderer(_this.renderOptions);
                    _this.directionsDisplay.setMap(map);
                    _this.directionsDisplay.addListener('directions_changed', function () {
                        _this.onChange.emit(_this.directionsDisplay.getDirections());
                    });
                }
                if (typeof _this.directionsService === 'undefined') {
                    _this.directionsService = new google.maps.DirectionsService;
                }
                if (typeof _this.panel === 'undefined') {
                    _this.directionsDisplay.setPanel(null);
                }
                else {
                    _this.directionsDisplay.setPanel(_this.panel);
                }
                // Render exist direction
                if (typeof _this.renderRoute === 'object' && _this.renderRoute !== null) {
                    _this.directionsDisplay.setDirections(_this.renderRoute);
                    _this.renderRoute = null; // or set undefined, ''
                }
                else {
                    // Request new direction
                    // Request new direction
                    _this.directionsService.route({
                        origin: _this.origin,
                        destination: _this.destination,
                        travelMode: _this.travelMode,
                        transitOptions: _this.transitOptions,
                        drivingOptions: _this.drivingOptions,
                        waypoints: _this.waypoints,
                        optimizeWaypoints: _this.optimizeWaypoints,
                        provideRouteAlternatives: _this.provideRouteAlternatives,
                        avoidHighways: _this.avoidHighways,
                        avoidTolls: _this.avoidTolls,
                    }, function (response, status) {
                        _this.onResponse.emit(response);
                        if (status === 'OK') {
                            _this.directionsDisplay.setDirections(response);
                            /**
                                         * Emit The DirectionsResult Object
                                         * https://developers.google.com/maps/documentation/javascript/directions?hl=en#DirectionsResults
                                         */
                            // Custom Markers
                            if (typeof _this.markerOptions !== 'undefined') {
                                // Remove origin markers
                                try {
                                    if (typeof _this.originMarker !== 'undefined') {
                                        google.maps.event.clearListeners(_this.originMarker, 'click');
                                        _this.originMarker.setMap(null);
                                    }
                                    if (typeof _this.destinationMarker !== 'undefined') {
                                        google.maps.event.clearListeners(_this.destinationMarker, 'click');
                                        _this.destinationMarker.setMap(null);
                                    }
                                    _this.waypointsMarker.forEach(function (w) {
                                        if (typeof w !== 'undefined') {
                                            google.maps.event.clearListeners(w, 'click');
                                            w.setMap(null);
                                        }
                                    });
                                }
                                catch (/** @type {?} */ err) {
                                    console.error('Can not reset custom marker.', err);
                                }
                                // Set custom markers
                                var /** @type {?} */ _route_1 = response.routes[0].legs[0];
                                try {
                                    // Origin Marker
                                    if (typeof _this.markerOptions.origin !== 'undefined') {
                                        _this.markerOptions.origin.map = map;
                                        _this.markerOptions.origin.position = _route_1.start_location;
                                        _this.originMarker = _this.setMarker(map, _this.originMarker, _this.markerOptions.origin, _route_1.start_address);
                                    }
                                    // Destination Marker
                                    if (typeof _this.markerOptions.destination !== 'undefined') {
                                        _this.markerOptions.destination.map = map;
                                        _this.markerOptions.destination.position = _route_1.end_location;
                                        _this.destinationMarker = _this.setMarker(map, _this.destinationMarker, _this.markerOptions.destination, _route_1.end_address);
                                    }
                                    // Waypoints Marker
                                    if (typeof _this.markerOptions.waypoints !== 'undefined') {
                                        _this.waypoints.forEach(function (waypoint, index) {
                                            // If waypoints are not array then set all the same
                                            if (!Array.isArray(_this.markerOptions.waypoints)) {
                                                _this.markerOptions.waypoints.map = map;
                                                _this.markerOptions.waypoints.position = _route_1.via_waypoints[index];
                                                _this.waypointsMarker.push(_this.setMarker(map, waypoint, _this.markerOptions.waypoints, _route_1.via_waypoints[index]));
                                            }
                                            else {
                                                _this.markerOptions.waypoints[index].map = map;
                                                _this.markerOptions.waypoints[index].position = _route_1.via_waypoints[index];
                                                _this.waypointsMarker.push(_this.setMarker(map, waypoint, _this.markerOptions.waypoints[index], _route_1.via_waypoints[index]));
                                            }
                                        }); // End forEach
                                    }
                                }
                                catch (/** @type {?} */ err) {
                                    console.error('MarkerOptions error.', err);
                                }
                            }
                        }
                    });
                }
            });
        };
        /**
         * Custom Origin and Destination Icon
         * \@memberof AgmDirection
         * @param {?} map map
         * @param {?} marker marker
         * @param {?} markerOpts properties
         * @param {?} content marker's infowindow content
         * @return {?} new marker
         */
        AgmDirection.prototype.setMarker = /**
         * Custom Origin and Destination Icon
         * \@memberof AgmDirection
         * @param {?} map map
         * @param {?} marker marker
         * @param {?} markerOpts properties
         * @param {?} content marker's infowindow content
         * @return {?} new marker
         */
        function (map, marker, markerOpts, content) {
            var _this = this;
            if (typeof this.infoWindow === 'undefined') {
                this.infoWindow = new google.maps.InfoWindow({});
                this.sendInfoWindow.emit(this.infoWindow);
            }
            marker = new google.maps.Marker(markerOpts);
            marker.addListener('click', function () {
                var /** @type {?} */ infowindoContent = typeof markerOpts.infoWindow === 'undefined' ? content : markerOpts.infoWindow;
                _this.infoWindow.setContent(infowindoContent);
                _this.infoWindow.open(map, marker);
            });
            return marker;
        };
        AgmDirection.decorators = [
            { type: core.Directive, args: [{
                        selector: 'agm-direction',
                    },] }
        ];
        /** @nocollapse */
        AgmDirection.ctorParameters = function () { return [
            { type: GoogleMapsAPIWrapper, },
        ]; };
        AgmDirection.propDecorators = {
            "origin": [{ type: core.Input },],
            "destination": [{ type: core.Input },],
            "travelMode": [{ type: core.Input },],
            "transitOptions": [{ type: core.Input },],
            "drivingOptions": [{ type: core.Input },],
            "waypoints": [{ type: core.Input },],
            "optimizeWaypoints": [{ type: core.Input },],
            "provideRouteAlternatives": [{ type: core.Input },],
            "avoidHighways": [{ type: core.Input },],
            "avoidTolls": [{ type: core.Input },],
            "renderOptions": [{ type: core.Input },],
            "visible": [{ type: core.Input },],
            "panel": [{ type: core.Input },],
            "markerOptions": [{ type: core.Input },],
            "infoWindow": [{ type: core.Input },],
            "renderRoute": [{ type: core.Input },],
            "onChange": [{ type: core.Output },],
            "onResponse": [{ type: core.Output },],
            "sendInfoWindow": [{ type: core.Output },],
        };
        return AgmDirection;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AgmDirectionModule = /** @class */ (function () {
        function AgmDirectionModule() {
        }
        /**
         * @return {?}
         */
        AgmDirectionModule.forRoot = /**
         * @return {?}
         */
        function () {
            return {
                ngModule: AgmDirectionModule,
            };
        };
        AgmDirectionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        declarations: [
                            AgmDirection,
                        ],
                        exports: [
                            AgmDirection,
                        ]
                    },] }
        ];
        return AgmDirectionModule;
    }());

    exports.AgmDirectionModule = AgmDirectionModule;
    exports.ɵa = AgmDirection;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=agm-direction.umd.js.map
